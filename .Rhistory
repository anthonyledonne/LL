lm(y~x)
x <- c(0.8, 0.47, 0.51, 0.73, 0.36, 0.58, 0.57, 0.85, 0.44, 0.42)
mean(x0)
mean(x)
x <- c(0.8, 0.47, 0.51, 0.73, 0.36, 0.58, 0.57, 0.85, 0.44, 0.42)
y <- c(1.39, 0.72, 1.55, 0.48, 1.19, -1.59, 1.23, -0.65, 1.49, 0.05)
x <- x-mean(x)
y <- y-mean(y)
x
y
lm(y~x)
freqData <- as.data.frame(table(x,y))
freqData
library(ggplot2)
p <- ggplot(filter(freqData, freqData > 0 ), aes(x=x, y = y))
p <- ggplot(filter(freqData, fre > 0 ), aes(x=x, y = y))
p <- ggplot(filter(freqData, freq > 0 ), aes(x=x, y = y))
p <- ggplot(filter(freqData, Freq > 0 ), aes(x=x, y = y))
line(x, y)
lm(I(x)~I(y) - 1)
x <- c(0.8, 0.47, 0.51, 0.73, 0.36, 0.58, 0.57, 0.85, 0.44, 0.42)
y <- c(1.39, 0.72, 1.55, 0.48, 1.19, -1.59, 1.23, -0.65, 1.49, 0.05)
lm(y~0+x)
?qunif
qunif(.75)
x <- 1:4
p <- x/sum(x)
temp <- rbind(x, p)
rownames(temp) <- c("X", "Prob")
temp
weighted.mean(x, [])
weighted.mean(x, p)
library(swirl)
install_from_swirl("Exploratory Data Analysis")
library(swirl)
swirl()
library(swirl)
swirl
swirl()
install_from_swirl("Statistical Inference")
swirl()
(9)/36
.75
11/12
deck
1/52
52
1/13
0
3/13
2/52
2/13
2/51
.64
.64
mypdf
integrate(mypdf, 0, 1.6)
.16
1
sqrt(2)
.997*.001
.999*.915
.999*.015
.997*.001/.999*.015
(.997*.001)/(.999*.001+.015*.999)
(.997*.001) / (.997*.001 + .015*.999)
1/6
3.5
expect_dice()
expect_dice
dice_high
expect_dice(dice_high)
expect_dice(dice_low)
.5*(edh+edl)
integrate(myfunc, 0, 2)
spop
mean(spo)
mean(spop)
allsam
apply(allsam,1,mean)
mean(smeans)
dice_sqr
dice_sqr*dice_fair
ex2_fair <- dice_sqr*dice_fair
ex2_fair <- dice_sqr * dice_fair
ex2_fair <- sum(dice_fair * dice_sqr)
ex2_fair - 3.5^2
dice_high
sum(dice_high * dice_sqr)-edh^2
sd(apply(matrix(rnorm(10000),1000),1,mean))
1/sqrt(10)
1/sqrt(120)
sd(apply(matrix(runif(10000),1000),1,mean))
2/sqrt(10)
sd(apply(matrix(rpois(10000,4),1000),1,mean))
1/(2*sqrt(10))
sd(apply(matrix(sample(0:1,10000,TRUE),1000),1,mean))
5*.8
.8
.8^5
(5,x)*(.8)^x*(.2)^(5-x)
info()
choose(5,5)
x <- 3
choose(5,3)*(.8)^3*(.2)^(5-3) + choose(5,4)*(.8)^4*(.2)^(5-4) + choose(5,5)*(.8)^5*(.2)^(5-5)
pbinom(2,5,.8,lower.tail = FALSE)
qnorm(10)
qnorm(.1)
0
qnorm(.975,3,2)
1.96*2 + 3
pnorm(1200, mean = 1020, sd = 50, lower.tail = FALSE)
pnorm(1200, )
pnorm((1200-1020)/50,lower.tail=FALSE)
pnorm((1200-1020)/75,lower.tail=FALSE)
qnorm(.75,mean=1020,sd=50
)
.47
pnorm(qnorm(.53))
.53
ppois(3, (2.5*4))
ppois(3,2.5 * 4)
?pbinom
pbinom(5, 1000, .01, lower.tail = TRUE, log.p = FALSE)
ppois(5, lambda = n*p)
ppois(5, lambda = 1000*.01)
NEWcrossCorrelationBetweenBooks <- function(Book1, Book2, Days) {
library(plyr)
## Takes two numeric vectors as inputs
## and computes their cross-correlation
Days <- min(Days, nrow(Book1[2]), nrow(Book2[2])))
x <- tail(Book1[2], Days)
y <- tail(Book2[2], Days)
## Ensure ranks are numeric
x <- as.numeric(x[,1])
y <- as.numeric(y[,1])
## Create time series
x.ts <- ts(x)
y.ts <- ts(y)
## Find Min and Max CCF
d <- ccf(x.ts, y.ts, lag.max = 20, plot = TRUE, ylab = "CCF", main = paste(names(Book1[2]), "&", names(Book2[2]), sep = " "))
cor = d$acf[,,1]
lag = d$lag[,,1]
res = data.frame(cor,lag)
res_min = res[which.min(res$cor),]
res_max = res[which.max(res$cor),]
rownames(res_min) <- NULL
rownames(res_max) <- NULL
list("max" = res_max, "min" = res_min)
}
setwd("apps/LL")
source("ingestCSVsFromDirectory.R")
source("compileUnitsSoldIntoDataFrame.R")
library(plyr)
## Note, if daily is set to true, you wont' be able to link Sales Ranks and Units Sold,
## since Units Sold comes to us in a weekly format. That also means we won't be able
## to calculate CCfs of Sales Ranks and Units Sold, nor will we be able to calculate
## lm fits of the two variables.
daily <- TRUE ## if false, weekly
###########################################################################################################################
##                                                                                                                       ##
##                                                      Sales Ranks                                                      ##
##                                                                                                                       ##
###########################################################################################################################
salesRanks <- ingestCSVsFromDirectory("data/salesRank")
tmpNames <- names(salesRanks)
## Do some cleaning and polishing...
salesRanks <- lapply(seq(salesRanks), function(i) {
y <- data.frame(salesRanks[[i]])
## Take only what we want
y <- y[1:(nrow(y)-2), 1:2]
## Change the column names
names(y) <- c("timestamp", names(salesRanks)[i])
## Force correct classes for columns
y[, names(salesRanks)[i]] <- as.numeric(gsub(",", "", y[, 2]))
## Fix timestamp format
y$timestamp <- as.Date(y$timestamp)
## Select the lowest rank of each day/week
if (daily) {
y <- data.frame(tapply(y[, 2], y$timestamp, min, na.rm = TRUE)) ## daily, in case we ever want it
} else if (!daily) {
y$week <- as.Date(cut(y$timestamp, breaks = "week", start.on.monday = FALSE)) + 6
y <- data.frame(tapply(y[, 2], y$week, min, na.rm = TRUE))
}
## Fix rownames and bring back timestamp
y$timestamp <- as.Date(rownames(y))
rownames(y) <- NULL
## Change the column names
names(y) <- c(paste(names(salesRanks)[i], "Sales Rank", sep = " "), "timestamp")
## Reorder columns
y <- y[c(2, 1)]
## Get rid of Infs
y[y == Inf] <- NA
return(y)
})
names(salesRanks) <- tmpNames
salesRanks.df <- join_all(salesRanks, by = "timestamp", type = "full")
###########################################################################################################################
##                                                                                                                       ##
##                                                      Units Sold                                                       ##
##                                                                                                                       ##
###########################################################################################################################
unitsSold <- ingestCSVsFromDirectory("data/unitsSold", 10)
tmpNames <- names(unitsSold)
## Do some cleaning and polishing...
unitsSold <- lapply(seq(unitsSold), function(i) {
y <- data.frame(unitsSold[[i]])
## Take only what we want
y <- y[1:(nrow(y)-1), 1:2]
## Change the column names
names(y) <- c("timestamp", names(unitsSold)[i])
## Force correct classes for columns
y[, names(unitsSold)[i]] <- as.numeric(gsub(",", "", y[, 2]))
y$timestamp <- as.Date(y$timestamp, "%m/%d/%y")
## Change the column names
names(y) <- c("timestamp", paste(names(unitsSold)[i], "Units Sold", sep = " "))
return(y)
})
names(unitsSold) <- tmpNames
unitsSold.df <- join_all(unitsSold, by = "timestamp", type = "full")
###########################################################################################################################
##                                                                                                                       ##
##                                                   List of Data Pairs                                                  ##
##                                                                                                                       ##
###########################################################################################################################
if (!daily) {
joined <- vector(mode = "list", length = length(unitsSold))
joined <- lapply(seq(joined), function(i) {
y <- join_all(list(salesRanks[[i]], unitsSold[[i]]),
by = "timestamp", type = "full")
#y <- y[complete.cases(y), ]
y <- y[order(y$timestamp), ]
rownames(y) <- NULL
return(y)
})
names(joined) <- names(unitsSold)
}
###########################################################################################################################
##                                                                                                                       ##
##                                                   CCFs between books                                                  ##
##                                                                                                                       ##
###########################################################################################################################
if(daily) {
crossCorrelationBetweenBooks <- function(Book1, Book2) {
library(plyr)
## Takes two numeric vectors as inputs
## and computes their cross-correlation
x <- Book1
y <- Book2
## Merge the two dataframes
dataset <- merge(x, y, by = "timestamp", all = TRUE)
## Ensure ranks are numeric
dataset[,2] <- as.numeric(dataset[,2])
dataset[,3] <- as.numeric(dataset[,3])
## Complete Cases
dataset <- dataset[complete.cases(dataset), ]
## Force timestamp to Date
dataset$timestamp <- as.Date(dataset$timestamp)
## Create time series
x.ts <- ts(dataset[,2])
y.ts <- ts(dataset[,3])
## Find Min and Max CCF
d <- ccf(x.ts, y.ts, lag.max = 20, plot = TRUE, ylab = "CCF", main = paste(names(Book1[2]), "&", names(Book2[2]), sep = " "))
cor = d$acf[,,1]
lag = d$lag[,,1]
res = data.frame(cor,lag)
res_min = res[which.min(res$cor),]
res_max = res[which.max(res$cor),]
rownames(res_min) <- NULL
rownames(res_max) <- NULL
list("max" = res_max, "min" = res_min)
}
}
lapply(salesRanks, function(x) NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, x, 14))
lapply(salesRanks, function(x) NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, x, 14))
NEWcrossCorrelationBetweenBooks <- function(Book1, Book2, Days) {
library(plyr)
## Takes two numeric vectors as inputs
## and computes their cross-correlation
Days <- min(Days, nrow(Book1[2]), nrow(Book2[2])))
x <- tail(Book1[2], Days)
y <- tail(Book2[2], Days)
## Ensure ranks are numeric
x <- as.numeric(x[,1])
y <- as.numeric(y[,1])
## Create time series
x.ts <- ts(x)
y.ts <- ts(y)
## Find Min and Max CCF
d <- ccf(x.ts, y.ts, lag.max = 20, plot = TRUE, ylab = "CCF", main = paste(names(Book1[2]), "&", names(Book2[2]), sep = " "))
cor = d$acf[,,1]
lag = d$lag[,,1]
res = data.frame(cor,lag)
res_min = res[which.min(res$cor),]
res_max = res[which.max(res$cor),]
rownames(res_min) <- NULL
rownames(res_max) <- NULL
list("max" = res_max, "min" = res_min)
}
lapply(salesRanks, function(x) NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, x, 14))
NEWcrossCorrelationBetweenBooks <- function(Book1, Book2, Days) {
library(plyr)
## Takes two numeric vectors as inputs
## and computes their cross-correlation
Days <- min(Days, nrow(Book1[2]), nrow(Book2[2])))
x <- tail(Book1[2], Days)
y <- tail(Book2[2], Days)
## Ensure ranks are numeric
x <- as.numeric(x[,1])
y <- as.numeric(y[,1])
## Create time series
x.ts <- ts(x)
y.ts <- ts(y)
## Find Min and Max CCF
d <- ccf(x.ts, y.ts, lag.max = 20, plot = TRUE, ylab = "CCF", main = paste(names(Book1[2]), "&", names(Book2[2]), sep = " "))
cor = d$acf[,,1]
lag = d$lag[,,1]
res = data.frame(cor,lag)
res_min = res[which.min(res$cor),]
res_max = res[which.max(res$cor),]
rownames(res_min) <- NULL
rownames(res_max) <- NULL
list("max" = res_max, "min" = res_min)
}
NEWcrossCorrelationBetweenBooks <- function(Book1, Book2, Days) {
library(plyr)
## Takes two numeric vectors as inputs
## and computes their cross-correlation
Days <- min(Days, nrow(Book1[2]), nrow(Book2[2])))
x <- tail(Book1[2], Days)
NEWcrossCorrelationBetweenBooks <- function(Book1, Book2, Days) {
library(plyr)
## Takes two numeric vectors as inputs
## and computes their cross-correlation
Days <- min(Days, nrow(Book1[2]), nrow(Book2[2]))
x <- tail(Book1[2], Days)
y <- tail(Book2[2], Days)
## Ensure ranks are numeric
x <- as.numeric(x[,1])
y <- as.numeric(y[,1])
## Create time series
x.ts <- ts(x)
y.ts <- ts(y)
## Find Min and Max CCF
d <- ccf(x.ts, y.ts, lag.max = 20, plot = TRUE, ylab = "CCF", main = paste(names(Book1[2]), "&", names(Book2[2]), sep = " "))
cor = d$acf[,,1]
lag = d$lag[,,1]
res = data.frame(cor,lag)
res_min = res[which.min(res$cor),]
res_max = res[which.max(res$cor),]
rownames(res_min) <- NULL
rownames(res_max) <- NULL
list("max" = res_max, "min" = res_min)
}
lapply(salesRanks, function(x) NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, x, 14))
lapply(salesRanks, function(x) NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, x, 31))
salesRanks <- ingestCSVsFromDirectory("data/salesRank")
source("ingestCSVsFromDirectory.R")
source("compileUnitsSoldIntoDataFrame.R")
library(plyr)
## Note, if daily is set to true, you wont' be able to link Sales Ranks and Units Sold,
## since Units Sold comes to us in a weekly format. That also means we won't be able
## to calculate CCfs of Sales Ranks and Units Sold, nor will we be able to calculate
## lm fits of the two variables.
daily <- TRUE ## if false, weekly
###########################################################################################################################
##                                                                                                                       ##
##                                                      Sales Ranks                                                      ##
##                                                                                                                       ##
###########################################################################################################################
salesRanks <- ingestCSVsFromDirectory("data/salesRank")
tmpNames <- names(salesRanks)
salesRanks
source("ingestCSVsFromDirectory.R")
source("compileUnitsSoldIntoDataFrame.R")
library(plyr)
## Note, if daily is set to true, you wont' be able to link Sales Ranks and Units Sold,
## since Units Sold comes to us in a weekly format. That also means we won't be able
## to calculate CCfs of Sales Ranks and Units Sold, nor will we be able to calculate
## lm fits of the two variables.
daily <- TRUE ## if false, weekly
###########################################################################################################################
##                                                                                                                       ##
##                                                      Sales Ranks                                                      ##
##                                                                                                                       ##
###########################################################################################################################
salesRanks <- ingestCSVsFromDirectory("data/salesRank")
tmpNames <- names(salesRanks)
## Do some cleaning and polishing...
salesRanks <- lapply(seq(salesRanks), function(i) {
y <- data.frame(salesRanks[[i]])
## Take only what we want
y <- y[1:(nrow(y)-2), 1:2]
## Change the column names
names(y) <- c("timestamp", names(salesRanks)[i])
## Force correct classes for columns
y[, names(salesRanks)[i]] <- as.numeric(gsub(",", "", y[, 2]))
## Fix timestamp format
y$timestamp <- as.Date(y$timestamp)
## Select the lowest rank of each day/week
if (daily) {
y <- data.frame(tapply(y[, 2], y$timestamp, min, na.rm = TRUE)) ## daily, in case we ever want it
} else if (!daily) {
y$week <- as.Date(cut(y$timestamp, breaks = "week", start.on.monday = FALSE)) + 6
y <- data.frame(tapply(y[, 2], y$week, min, na.rm = TRUE))
}
## Fix rownames and bring back timestamp
y$timestamp <- as.Date(rownames(y))
rownames(y) <- NULL
## Change the column names
names(y) <- c(paste(names(salesRanks)[i], "Sales Rank", sep = " "), "timestamp")
## Reorder columns
y <- y[c(2, 1)]
## Get rid of Infs
y[y == Inf] <- NA
return(y)
})
names(salesRanks) <- tmpNames
salesRanks.df <- join_all(salesRanks, by = "timestamp", type = "full")
salesRanks.df
head(salesRanks.df)
salesRanks <- ingestCSVsFromDirectory("data/salesRank")
head(salesRanks[[1]])
NEWcrossCorrelationBetweenBooks <- function(Book1, Book2, Days) {
library(plyr)
## Takes two numeric vectors as inputs
## and computes their cross-correlation
Days <- min(Days, nrow(Book1[2]), nrow(Book2[2]))
x <- tail(Book1[2], Days)
y <- tail(Book2[2], Days)
## Ensure ranks are numeric
x <- as.numeric(x[,1])
y <- as.numeric(y[,1])
## Create time series
x.ts <- ts(x)
y.ts <- ts(y)
## Find Min and Max CCF
d <- ccf(x.ts, y.ts, lag.max = 20, plot = TRUE, ylab = "CCF", main = paste(names(Book1[2]), "&", names(Book2[2]), sep = " "))
cor = d$acf[,,1]
lag = d$lag[,,1]
res = data.frame(cor,lag)
res_min = res[which.min(res$cor),]
res_max = res[which.max(res$cor),]
rownames(res_min) <- NULL
rownames(res_max) <- NULL
list("max" = res_max, "min" = res_min)
}
lapply(salesRanks, function(x) NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, x, 40))
lapply(salesRanks, function(x) NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, x, 40))
lapply(salesRanks, function(x) NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, x, 39))
salesRanks$`After the Kiss`
tail(salesRanks$`After the Kiss`)
tail(salesRanks$`After the Kiss`, 1000)
tail(salesRanks$`After the Kiss`, 10000)
tail(salesRanks$`After the Kiss`, 100000)
NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, salesRanks$`After the Kiss`)
NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, salesRanks$`After the Kiss`, 40)
?min
NEWcrossCorrelationBetweenBooks <- function(Book1, Book2, Days) {
library(plyr)
## Takes two numeric vectors as inputs
## and computes their cross-correlation
Days <- min(Days, nrow(Book1[2]), nrow(Book2[2]), na.rm = TRUE)
x <- tail(Book1[2], Days)
y <- tail(Book2[2], Days)
## Ensure ranks are numeric
x <- as.numeric(x[,1])
y <- as.numeric(y[,1])
## Create time series
x.ts <- ts(x)
y.ts <- ts(y)
## Find Min and Max CCF
d <- ccf(x.ts, y.ts, lag.max = 20, plot = TRUE, ylab = "CCF", main = paste(names(Book1[2]), "&", names(Book2[2]), sep = " "))
cor = d$acf[,,1]
lag = d$lag[,,1]
res = data.frame(cor,lag)
res_min = res[which.min(res$cor),]
res_max = res[which.max(res$cor),]
rownames(res_min) <- NULL
rownames(res_max) <- NULL
list("max" = res_max, "min" = res_min)
}
lapply(salesRanks, function(x) NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, x, 39))
lapply(salesRanks, function(x) NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, x, 39))
NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, salesRanks$`After the Kiss`, 39)
NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, salesRanks$`After the Kiss`, 30)
NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, salesRanks$`After the Kiss`, 10)
NEWcrossCorrelationBetweenBooks <- function(Book1, Book2, Days) {
library(plyr)
## Takes two numeric vectors as inputs
## and computes their cross-correlation
Days <- min(Days, nrow(Book1[2]), nrow(Book2[2]), na.rm = TRUE)
x <- tail(Book1[2], Days)
y <- tail(Book2[2], Days)
## Ensure ranks are numeric
x <- as.numeric(x[,1])
y <- as.numeric(y[,1])
## Create time series
x.ts <- ts(x)
y.ts <- ts(y)
## Find Min and Max CCF
d <- ccf(x.ts, y.ts, lag.max = 20, plot = TRUE, ylab = "CCF", main = paste(names(Book1[2]), "&", names(Book2[2]), sep = " "))
cor = d$acf[,,1]
lag = d$lag[,,1]
res = data.frame(cor,lag)
res_min = res[which.min(res$cor),]
res_max = res[which.max(res$cor),]
rownames(res_min) <- NULL
rownames(res_max) <- NULL
list("max" = res_max, "min" = res_min)
}
NEWcrossCorrelationBetweenBooks(salesRanks$`Blurred Lines`, salesRanks$`Blurred Lines`, 30)
